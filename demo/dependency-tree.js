// Generated by CoffeeScript 1.12.7
(function () {
  var dependencyDict, levelHeight, maximum, parseConll, tagDict, under, wordHeight, wordWidth;

  wordWidth = 60;

  wordHeight = 20;

  levelHeight = function (level) {
    return 2 + Math.pow(level, 1.8) * 10;
  };

  window.drawTree = function (svgElement, conllData) {
    var arrows, data, dependencies, e, edge, edges, i, item, j, k, len, len1, len2, svg, tags, treeHeight, treeWidth, triangle, words;
    svg = d3.select(svgElement);
    data = parseConll(conllData);
    edges = (function () {
      var i, len, results;
      results = [];
      for (i = 0, len = data.length; i < len; i++) {
        item = data[i];
        if (item.id) {
          results.push(item);
        }
      }
      return results;
    })();
    for (i = 0, len = edges.length; i < len; i++) {
      edge = edges[i];
      for (j = 0, len1 = edges.length; j < len1; j++) {
        edge = edges[j];
        edge.level = 1 + maximum((function () {
          var k, len2, results;
          results = [];
          for (k = 0, len2 = edges.length; k < len2; k++) {
            e = edges[k];
            if (under(edge, e)) {
              results.push(e.level);
            }
          }
          return results;
        })());
      }
    }
    treeWidth = wordWidth * data.length - wordWidth / 3;
    treeHeight = levelHeight(maximum((function () {
      var k, len2, results;
      results = [];
      for (k = 0, len2 = data.length; k < len2; k++) {
        edge = data[k];
        results.push(edge.level);
      }
      return results;
    })())) + 2 * wordHeight;
    for (k = 0, len2 = data.length; k < len2; k++) {
      item = data[k];
      item.bottom = treeHeight - 1.8 * wordHeight;
      item.top = item.bottom - levelHeight(item.level);
      item.left = treeWidth - item.id * wordWidth;
      item.right = treeWidth - item.head * wordWidth;
      item.mid = (item.right + item.left) / 2;
      item.diff = (item.right - item.left) / 4;
      item.arrow = item.top + (item.bottom - item.top) * .25;
    }
    svg.selectAll('text, path').remove();
    svg.attr('xmlns', 'http://www.w3.org/2000/svg');
    svg.attr('width', treeWidth + 2 * wordWidth / 3).attr('height', treeHeight + wordHeight / 2);
    words = svg.selectAll('.form').data(data).enter().append('text').text(function (d) {
      return d.form;
    }).attr('class', function (d) {
      return "form w" + d.id;
    }).attr('x', function (d) {
      return treeWidth - wordWidth * d.id;
    }).attr('y', treeHeight - wordHeight).on('mouseover', function (d) {
      svg.selectAll('.form, .deprel, .edge, .arrow').classed('active', false);
      svg.selectAll('.tag').attr('opacity', 0);
      svg.selectAll(".w" + d.id).classed('active', true);
      return svg.select(".tag.w" + d.id).attr('opacity', 1);
    }).on('mouseout', function (d) {
      svg.selectAll('.form, .deprel, .edge, .arrow').classed('active', false);
      return svg.selectAll('.tag').attr('opacity', 0);
    }).attr('text-anchor', 'middle');
    tags = svg.selectAll('.tag').data(data).enter().append('text').text(function (d) {
      return d.tag;
    }).attr('class', function (d) {
      return "tag w" + d.id;
    }).attr('x', function (d) {
      return treeWidth - wordWidth * d.id;
    }).attr('y', treeHeight).attr('opacity', 0).attr('text-anchor', 'middle').attr('font-size', '90%');
    edges = svg.selectAll('.edge').data(data).enter().append('path').filter(function (d) {
      return d.id;
    }).attr('class', function (d) {
      return "edge w" + d.id + " w" + d.head;
    }).attr('d', function (d) {
      return "M" + d.left + "," + d.bottom + " C" + (d.mid - d.diff) + "," + d.top + " " + (d.mid + d.diff) + "," + d.top + " " + d.right + "," + d.bottom;
    }).attr('fill', 'none').attr('stroke', 'black').attr('stroke-width', '1.5');
    dependencies = svg.selectAll('.deprel').data(data).enter().append('text').filter(function (d) {
      return d.id;
    }).text(function (d) {
      return d.deprel;
    }).attr('class', function (d) {
      return "deprel w" + d.id + " w" + d.head;
    }).attr('x', function (d) {
      return d.mid;
    }).attr('y', function (d) {
      return d.arrow - 7;
    }).attr('text-anchor', 'middle').attr('font-size', '90%');
    triangle = d3.svg.symbol().type('triangle-up').size(5);
    return arrows = svg.selectAll('.arrow').data(data).enter().append('path').filter(function (d) {
      return d.id;
    }).attr('class', function (d) {
      return "arrow w" + d.id + " w" + d.head;
    }).attr('d', triangle).attr('transform', function (d) {
      return "translate(" + d.mid + ", " + d.arrow + ") rotate(" + (d.id < d.head ? '' : '-') + "90)";
    }).attr('fill', 'none').attr('stroke', 'black').attr('stroke-width', '1.5');
  };

  maximum = function (array) {
    return Math.max(0, Math.max.apply(null, array));
  };

  under = function (edge1, edge2) {
    var ma, mi, ref;
    ref = edge1.id < edge1.head ? [edge1.id, edge1.head] : [edge1.head, edge1.id], mi = ref[0], ma = ref[1];
    return edge1.id !== edge2.id && edge2.id >= mi && edge2.head >= mi && edge2.id <= ma && edge2.head <= ma;
  };

  parseConll = function (conllData) {
    var _, cpos, data, deprel, form, fpos, head, i, id, len, line, ref, ref1, ref2, tag, upos, xpos;
    data = [];
    data.push({
      id: 0,
      form: 'ریشه',
      tag: tagDict['root'],
      level: 0
    });
    ref = conllData.split('\n').slice(2);
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      if (!(line)) {
        continue;
      }
      ref1 = line.split('\t'), id = ref1[0], form = ref1[1], _ = ref1[2], upos = ref1[3], xpos = ref1[4], _ = ref1[5], head = ref1[6], deprel = ref1[7];
      if (xpos.includes('_')) {
        ref2 = xpos.split('_'), cpos = ref2[0], fpos = ref2[1];
        tag = tagDict[cpos] + ' ' + tagDict[fpos];
      } else {
        tag = tagDict[xpos];
      }
      data.push({
        id: Number(id),
        form: form,
        tag: tag,
        head: Number(head),
        deprel: dependencyDict[deprel],
        level: 1
      });
    }
    return data;
  };

  tagDict = {
    'ADJ': 'صفت',
    'ADP': 'حرف اضافه',
    'ADV': 'قید',
    'AUX': 'فعل کمکی',
    'CCONJ': 'حرف ربط همپایه‌ساز',
    'DET': 'حرف تعریف',
    'INTJ': 'حرف ندا',
    'NOUN': 'اسم',
    'NUM': 'شمار',
    'PART': 'جزء دستوری',
    'PRON': 'ضمیر',
    'PROPN': 'اسم خاص',
    'PUNCT': 'نشانه سجاوندی',
    'SCONJ': 'حرف ربط وابسته‌ساز',
    'SYM': 'نماد',
    'VERB': 'فعل',
    'X': 'سایر',

    '': '',
    '1': 'اول',
    '2': 'دوم',
    '3': 'سوم',
    'ACT': 'معلوم',
    'ADJ': 'صفت',
    'ADR': 'نقش نمای ندا',
    'ADV': 'قید',
    'AJCM': 'تفضیلی',
    'AJP': 'مطلق',
    'AJSUP': 'عالی',
    'AMBAJ': 'صفت مبهم',
    'ANM': 'جاندار',
    'AVCM': 'تفضیلی',
    'AVP': 'مطلق',
    'AY': 'آینده اخباری',
    'CL': 'سببی',
    'COM': 'تفضیلی',
    'CONJ': 'نقش نمای همپایگی',
    'CREFX': 'بازتابی مشترک',
    'DEMAJ': 'صفت اشاره',
    'DEMON': 'اشاره',
    'DET': 'حرف تعریف',
    'EXAJ': 'صفت تعجبی',
    'GB': 'گذشته بعید اخباری',
    'GBEL': 'گذشته بعید التزامی',
    'GBES': 'گذشته بعید استمراری اخباری',
    'GBESE': 'گذشته بعید استمراری التزامی',
    'GEL': 'گذشته التزامی',
    'GES': 'گذشته استمراری اخباری',
    'GESEL': 'گذشته استمراری التزامی',
    'GN': 'گذشته نقلی اخباری',
    'GNES': 'گذشته نقلی استمراری اخباری',
    'GS': 'گذشته ساده اخباری',
    'H': 'حال اخباری',
    'HA': 'حال امری',
    'HEL': 'حال التزامی',
    'IANM': 'بی جان',
    'IDEN': 'شاخص',
    'INTG': 'پرسشی',
    'ISO': 'واژه تنها',
    'JOPER': 'شخصی پیوسته',
    'MODE': 'وجه',
    'MODL': 'وجهی',
    'N': 'اسم',
    'NUM': 'شمار',
    'NXT': 'چسبیدگی از چپ',
    'PART': 'جزء دستوری',
    'PASS': 'مجهول',
    'PERS': 'شخص',
    'PLUR': 'جمع',
    'POSADR': 'پسین',
    'POSNUM': 'صفت شمارشی پسین',
    'POST': 'مطلق',
    'POSTP': 'حرف اضافه پسین',
    'PR': 'ضمیر',
    'PRADR': 'پیشین',
    'PREM': 'پیش توصیفگر',
    'PRENUM': 'صفت شمارشی پیشین',
    'PREP': 'حرف اضافه پیشین',
    'PRV': 'چسبیدگی از راست',
    'PSUS': 'شبه جمله',
    'PUNC': 'علامت نگارشی',
    'QUAJ': 'صفت پرسشی',
    'RECPR': 'متقابل',
    'SADV': 'مختص',
    'SEPER': 'شخصی جدا',
    'SING': 'مفرد',
    'SUBR': 'نقش نمای وابستگی',
    'SUP': 'عالی',
    'UCREFX': 'بازتابی غیرمشترک',
    'V': 'فعل',
    'ROOT': ''
  };

  dependencyDict = {
    'acl': 'بندِ نام‌آمیخته',
    'acl:relcl': 'توصیف‌گر بند موصولی',
    'advcl': 'توصیف‌گر بند قیدی',
    'advmod': 'توصیف‌گر قیدی',
    'advmod:emph': 'تأکیدافزای',
    'advmod:lmod': 'توصیف‌گر قید مکانی',
    'amod': 'توصیف‌گر صفتی',
    'appos': 'توصیف‌گر دوسویه',
    'aux': 'فعل کمکی',
    'aux:pass': 'فعل کمکی مجهول',
    'case': 'case marking',
    'cc': 'حرف ربط همپایه‌ساز',
    'cc:preconj': 'preconjunct',
    'ccomp': 'مکملِ بندی',
    'clf': 'طبقه‌بند',
    'compound': 'ترکیب',
    'compound:lvc': 'سازهٔ فعلِ همکرد',
    'compound:prt': 'ادات فعل گروهی',
    'compound:redup': 'ترکیبات بازتکرار شده',
    'compound:svc': 'serial verb compounds',
    'conj': 'حرف ربط',
    'cop': 'فعل ربطی',
    'csubj': 'فاعلِ بندی',
    'csubj:outer': 'outer clause clausal subject',
    'csubj:pass': 'clausal passive subject',
    'dep': 'وابسته نامعلوم',
    'det': 'تخصیص‌گر',
    'det:numgov': 'کمیت‌نمای ضمیری حاکم بر حالت اسم',
    'det:nummod': 'pronominal quantifier agreeing in case with the noun',
    'det:poss': 'تخصیص‌گر ملکی',
    'discourse': 'عنصر گفتمان',
    'dislocated': 'dislocated elements',
    'expl': 'پوچ‌واژه',
    'expl:impers': 'پوچ‌واژه غیرشخصی',
    'expl:pass': 'ضمیر انعکاسی به‌کاررفته در مجهول انعکاسی',
    'expl:pv': 'واژه‌بست انعکاسی با یک فعل ذاتاً انعکاسی',
    'fixed': 'عبارت چندکلمه‌ای ثابت',
    'flat': 'عبارت چندکلمه‌ای تخت',
    'flat:foreign': 'واژه بیگانه',
    'flat:name': 'اسامی',
    'goeswith': 'در کنارِ',
    'iobj': 'مفعول غیر مستقیم',
    'list': 'فهرست',
    'mark': 'نشانگر',
    'nmod': 'توصیف‌گر ساخت‌واژه',
    'nmod:poss': 'توصیف‌گر ساخت‌واژهٔ مالکیتی',
    'nmod:tmod': 'توصیف‌گر زمانی',
    'nsubj': 'nominal subject',
    'nsubj:outer': 'outer clause nominal subject',
    'nsubj:pass': 'passive nominal subject',
    'nummod': 'توصیف‌گر عددی',
    'nummod:gov': 'توصیف‌گر عددی درباره اسم',
    'obj': 'مفعول',
    'obl': 'oblique nominal',
    'obl:agent': 'توصیف‌گر عامل',
    'obl:arg': 'oblique argument',
    'obl:lmod': 'توصیف‌گر مکانی',
    'obl:tmod': 'توصیف‌گر زمانی',
    'orphan': 'بدون جایگاه',
    'parataxis': 'همپایگی',
    'punct': 'نشانه سجاوندی',
    'reparandum': 'ناروانی نادیده‌گرفته شده',
    'root': 'ریشه',
    'vocative': 'ندایی',
    'xcomp': 'open clausal complement',

    '': '',
    'NE': 'اسم‌یار',
    'PART': 'افزودۀ پرسشی فعل',
    'APP': 'بدل',
    'NCL': 'بند اسم',
    'AJUCL': 'بند افزودۀ فعل',
    'PARCL': 'بند فعل وصفی',
    'TAM': 'تمییز',
    'NPRT': 'جزء اسمی',
    'LVP': 'جزء همکرد',
    'NPP': 'حرف اضافه اسم',
    'VPRT': 'حرف اضافه فعلی',
    'COMPPP': 'حرف اضافۀ تفضیلی',
    'ROOT': 'ریشه جمله',
    'NPOSTMOD': 'صفت پسین اسم',
    'NPREMOD': 'صفت پیشین اسم',
    'PUNC': 'علائم نگارشی',
    'SBJ': 'فاعل',
    'NVE': 'فعل‌یار',
    'ENC': 'فعل‏یار پی‏بستی',
    'ADV': 'قید',
    'NADV': 'قید اسم',
    'PRD': 'گزاره',
    'ACL': 'متمم بندی صفت',
    'VCL': 'متمم بندی فعل',
    'AJPP': 'متمم حرف اضافه‌ای صفت',
    'ADVC': 'متمم قیدی فعل',
    'NEZ': 'متمم نشانۀ اضافه‌ای صفت',
    'PROG': 'مستمرساز',
    'MOS': 'مسند',
    'MOZ': 'مضافٌ‌الیه',
    'OBJ': 'مفعول',
    'VPP': 'مفعول حرف اضافه‌ای',
    'OBJ2': 'مفعول دوم',
    'MESU': 'ممیز',
    'AJCONJ': 'هم‌پایه صفت',
    'PCONJ': 'هم‌پایۀ حرف اضافه',
    'NCONJ': 'هم‏پایه اسم',
    'VCONJ': 'هم‏پایه فعل',
    'AVCONJ': 'هم‏پایه قید',
    'POSDEP': 'وابسته پسین',
    'PREDEP': 'وابسته پیشین',
    'APOSTMOD': 'وابستۀ پسین صفت',
    'APREMOD': 'وابستۀ پیشین صفت'
  };

}).call(this);

//# sourceMappingURL=universal-dependency-tree.js.map
